---
layout: post
title: Malware Analysis - RogueRobin
categories: MalwareAnalysis
---
![Intro-picture](/img/DarkHydrus/darkhydrus_banner.jpg){:class="img-responsive"}

### Sommaire

* Introduction
* Reconnaissance
* DarkHydrus APT
* Analysis
  * A) Anti-VM et anti-debug
  * B) Méthodes de persistance
  * C) Exfiltration d’informations
    * 1) Principe de l’exfiltration DNS
    * 2) Exfiltration
  * D) Récolte d’informations systèmes
  * E) C2 Instruction handler
* Indicators of compromise

### Introduction
Le sample analysé possède le hash suivant:
> 2f22d521a1945d02380057a636e1032b

Le sample est téléchargeable sur [VirusBay](https://beta.virusbay.io/sample/browse/2f22d521a1945d02380057a636e1032b).

_Disclaimer habituel: le sample est en théorie inoffensif puisque les serveurs de contrôles n’existent plus, et que le malware n’a pas de potentiel destructeur sur un système infecté, mais une grande prudence reste recommandée lors de la manipulation du fichier._

### Reconnaissance
Le sample reste encore assez discret, sachant que celui-ci date déjà de plusieurs mois à l’heure de l’écriture du présent article, d'après [VirusTotal](https://www.virustotal.com/#/file/6c014eddb7622e5e48c3e9d10a6ebaa02b2fe7b3318ab4f2d4daf1a619ed913c):
![picture](/img/DarkHydrus/0.PNG){:class="img-responsive"}

Mention spéciale pour les antivirus ClamAV, Microsoft-Defender et Ikarus qui ont tous trois détectés précisément le malware:
![picture](/img/DarkHydrus/01.PNG){:class="img-responsive"}
![picture](/img/DarkHydrus/02.PNG){:class="img-responsive"}
![picture](/img/DarkHydrus/03.PNG){:class="img-responsive"}

Le binaire ne semble pas packé au vu de l’entropie du fichier:
![picture](/img/DarkHydrus/B.PNG){:class="img-responsive"}

Point positif pour l’analyse, le malware a été écrit en dans un langage [.Net](https://fr.wikipedia.org/wiki/Microsoft_.NET) (dans le cas présent en C#):
![picture](/img/DarkHydrus/A.PNG){:class="img-responsive"}
L’avantage d’un malware écrit dans un langage [.Net](https://fr.wikipedia.org/wiki/Microsoft_.NET) réside dans le fait que ce langage n’est pas compilé, et peut donc être facilement être reverse. Il est possible de retrouver le code source original du programme.

Enfin, le malware n’est ni packé ni obfusqué, ce qui fait que les chaînes de caractères du binaire sont visibles en clair. Ces chaînes permettent de grignoter quelques informations sur les fonctionnalités du malware avant d’entamer l’analyse, mais rien de bien important ou de décisif dans le cas présent.

### DarkHydrus APT
Le malware [RogueRobin](https://malpedia.caad.fkie.fraunhofer.de/details/ps1.roguerobin) est attribué à un groupe émergent appelé [DarkHydrus](https://attack.mitre.org/groups/G0079/). Ce groupe, apparu pour la première fois en août 2018, possède deux campagnes malveillantes à son actif.

[La première](https://www.cybersecurity-review.com/news-august-2018/new-actor-darkhydrus-targets-middle-east-with-open-source-phishing/) réside sur l’outil open-source [Phishery](https://github.com/ryhanson/phishery), et vise à dérober des identifiants d’entités gouvernementales du moyen orient, via des documents Words malveillants.

[La deuxième campagne](https://www.cybersecurity-review.com/news-january-2019/darkhydrus-abuses-google-drive-to-spread-roguerobin-trojan/) active du groupe met en avant le malware qui fait l’objet de l’analyse présente. Celle-ci cible des groupes politiques actifs au moyen orient, et date de janvier 2019. Le malware étudié s’inscrit donc dans des objectifs géopolitiques, et le groupe [DarkHydrus](https://attack.mitre.org/groups/G0079/) risque de nouveau de faire parler de lui dans un futur proche.

### Analysis
### A) Anti-VM et anti-debug
Avant toute action, le malware commence par chercher à détecter si l'environnement d’exécution est compromis, à savoir s‘il s’agit d’une machine virtuelle d’analyse.

En premier lieu, c’est via le serial-number du BIOS de la machine, que la malware va chercher à détecter les machines virtuelles.

Le malware se base ici sur des commandes powershell externes pour toute la phase de détection de l’environnement. Dans le cas où l’une des compagnies de virtualisation ([VmWare](https://www.vmware.com/), [VirtualBox](https://www.virtualbox.org/wiki/Downloads), [BOSH](https://www.bosh.io/docs/), [Qemu](https://www.qemu.org/) ou [Xen](https://xenproject.org/)) est détectée, l'exécution du programme est immédiatement arrêtée:
![picture](/img/DarkHydrus/M.PNG){:class="img-responsive"}

C’est ensuite au tour du label du fabricant et du modèle de la machine que la détection d’une VM tentera d’être faite, via la commande powershell “gwmi win32_computersystem”:
![picture](/img/DarkHydrus/N.PNG){:class="img-responsive"}

Sur une machine VmWare, le résultat est le suivant par défaut:
![picture](/img/DarkHydrus/O.PNG){:class="img-responsive"}

Puis, c'est la quantité de mémoire vive disponible qui est scannée par le malware. Si cette quantité n'excède pas les 3Go, le flux d'exécution est stoppé. Bien souvent, les machines virtuelles d’analyse ou les sandbox n’ont pas besoin de beaucoup de performances, et puisque aujourd'hui, il est rare de trouver des machines ayant moins de 3Go de RAM, cette vérification est pertinente:
![picture](/img/DarkHydrus/P.PNG){:class="img-responsive"}
(_La variable ‘ulong’ = 2900000000u’_)

Pour continuer, le même type de vérification est fait sur le nombre de coeurs du processeur de la machine. Si la machine possède un unique coeur, celle-ci est considérée comme suspecte:
![picture](/img/DarkHydrus/Q.PNG){:class="img-responsive"}

C’est ensuite via les noms d’éditeurs relatifs aux processus en cours que le malware va essayer d’éviter l'analyse. Si un des processus provient de la suite [Sysinternals](https://docs.microsoft.com/en-us/sysinternals/) ([procmon](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) et [procexp](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer) par exemple) ou de l’éditeur [Wireshark](https://www.wireshark.org/), le malware se ferme:
![picture](/img/DarkHydrus/R.PNG){:class="img-responsive"}

Pour terminer, le malware vérifie si un [débugger](https://docs.microsoft.com/en-us/windows/desktop/api/debugapi/nf-debugapi-isdebuggerpresent) est attaché au processus:
![picture](/img/DarkHydrus/S.PNG){:class="img-responsive"}

Cette dernière vérification clôt la liste des techniques anti-analyses utilisées par le malware RogueRobin.

### B) Méthodes de persistance
De façon à passer inaperçu sur le système infecté, RogueRobinse copie dans le répertoire _AppData_, sous le nom ‘_OneDrive.exe_’, afin de ne pas éveiller les soupçons.
![picture](/img/DarkHydrus/T.PNG){:class="img-responsive"}
![picture](/img/DarkHydrus/U.PNG){:class="img-responsive"}

Pour survivre à un redémarrage de la machine, le binaire malveillant est ajouté au dossier contenant les exécutables à démarrer au lancement de la session, en créant un raccourci depuis le fichier ‘_OneDrive.exe_’ précédent:
![picture](/img/DarkHydrus/W.PNG){:class="img-responsive"}
![picture](/img/DarkHydrus/V.PNG){:class="img-responsive"}

### C) Exfiltration d’informations
Afin de se présenter aux serveurs de contrôles du malware, RogueRobin commence par extraire l’ID du processus malveillant avec la fonction _Process.GetCurrentProcess().Id_:
![picture](/img/DarkHydrus/X.PNG){:class="img-responsive"}

Dans mon cas, l’identifiant retourné par la fonction est _3856_.
Cet identifiant est converti en une chaine de caractère via une fonction qui attribue linéairement une lettre pour chaque chiffre du PID:
![picture](/img/DarkHydrus/Y.PNG){:class="img-responsive"}

La chaine obtenue dans mon cas est donc “_kpmn_”. A cette chaine de caractère s’ajoute la lettre “_a_” en début de chaine, et la lettre “_c_” en fin de chaine. La chaine finale devient donc “_akpmnc_”:
![picture](/img/DarkHydrus/Z.PNG){:class="img-responsive"}

Cette chaine sera désormais l’identifiant de la machine infectée. Afin de notifier le serveur de contrôle qu’une nouvelle machine est infectée, le malware va chercher à exfiltrer cet identifiant. La particularité du sample RogueRobin réside dans cette fonction d’exfiltration qui ne se fait pas via un simple flux TCP HTTP / HTTPS, mais via un abus du [protocole DNS](https://tools.ietf.org/html/rfc1034).

### 1) Principe de l’exfiltration DNS
L’exfiltration via un tunnel DNS consiste à extraire de l’information en abusant du protocole DNS. Le protocole DNS fonctionne sur un système décentralisé, permettant de retourner l’adresse IP d’un serveur en fonction de son [FQDN](https://en.wikipedia.org/wiki/Fully_qualified_domain_name). Pour convertir l’URL  “_www.exemple.com_” en une adresse IP, la machine source va interroger un des serveurs DNS principaux ([Top-Level Domain](https://en.wikipedia.org/wiki/Top-level_domain), ou TLD), en lui demandant l’adresse du serveur DNS responsable de la zone “_.com_”. Celui-ci retournera l’adresse demandé. Le client va ensuite demander l’adresse du serveur DNS responsable de la zone “_exemple.com_”. Enfin, c’est l’adresse du serveur “_www_” qui est demandée au DNS de la zone “_exemple.com_”.
De cette façon, un client est capable de traduire une URL en une IP.

[L'exfiltration DNS](https://blogs.akamai.com/2017/09/introduction-to-dns-data-exfiltration.html) consiste à interroger un serveur DNS compromis pour lui transmettre de l’information. Dans le cas présent, en essayant de retrouver l’IP de l’URL “_akpmnc.exemple.com_”, par le biais du protocole DNS, le serveur DNS “exemple.com” sera interrogé à propos de la machine “_akpmnc_”. Même si cette machine n’existe pas, si un adversaire malveillant contrôle le serveur DNS responsable de la zone “_exemple.com_”, il sera capable de récupérer la chaine “_akpmnc_”, et donc de lire de l’information extraite de la machine victime.

[L'exfiltration DNS](https://blogs.akamai.com/2017/09/introduction-to-dns-data-exfiltration.html) a l'avantage d’utiliser un protocole [très rarement filtré et surveillé](http://www.caida.org/~nevil/Bojan_Zdrnja_CompSci780_Project.pdf).

### 2) Exfiltration
Avant toute chose, le cache DNS est nettoyé avec la commande “_ipconfig /flushdns_”:
![picture](/img/DarkHydrus/ZA.PNG){:class="img-responsive"}

La commande powershell est exécutée de manière transparente pour l’utilisateur de la machine infectée:
![picture](/img/DarkHydrus/ZB.PNG){:class="img-responsive"}

Le malware utilise le binaire légitime “_nslookup.exe_” pour pratiquer l’exfiltration DNS. La commande [nslookup](https://en.wikipedia.org/wiki/Nslookup) est initialisée en fonction du mode de requête DNS souhaité, du timeout, et du domaine d’exfiltration:
![picture](/img/DarkHydrus/ZC.PNG){:class="img-responsive"}

Les types de requêtes DNS disponibles sont les suivantes:
![picture](/img/DarkHydrus/ZD.PNG){:class="img-responsive"}

Et la liste des domaines à contacter sont les suivants:
![picture](/img/DarkHydrus/ZE.PNG){:class="img-responsive"}

Ainsi la première commande effectuée par le malware est la suivante:
![picture](/img/DarkHydrus/ZF.PNG){:class="img-responsive"}

A noter qu’une nouvelle technique anti-debug est utilisée avant d’effectuer les commandes d’exfiltration DNS (bien que très sommaire). Si un débugger est détecté par le malware, alors aucun domaine d’exfiltration n’est contacté, et des informations inutiles sont transférées à un domaine légitime de google:
![picture](/img/DarkHydrus/ZG.PNG){:class="img-responsive"}

La chaine “_676f6f646c75636b_” est en fait un message de la part de l'auteur du malware, qui nous est directement destiné. Celui-ci correspond à la chaine hexadécimale “_goodluck_”:
![picture](/img/DarkHydrus/ZH.PNG){:class="img-responsive"}

Si tout se passe bien, la commande d’exfiltration générée plus tôt est enfin exécutée:
![picture](/img/DarkHydrus/ZI.PNG){:class="img-responsive"}
![picture](/img/DarkHydrus/ZJ.PNG){:class="img-responsive"}

Afin de vérifier si la requête a été correctement transmise, le malware analyse le retour de la commande nslookup:
![picture](/img/DarkHydrus/ZK.PNG){:class="img-responsive"}

Le malware va continuer de sélectionner un type de message DNS aléatoire associé à l’entièreté de la liste de domaine à contacter, jusqu'à tomber sur un serveur en ligne.

Puisque la liste des serveurs de contrôle est trop vieille à l’heure de mon analyse, j’utilise ici l’outil ApateDNS pour retourner une réponse positive à toutes les requêtes effectuées par le malware:
![picture](/img/DarkHydrus/ZL.PNG){:class="img-responsive"}

De ce fait, le malware considère les serveurs de contrôle comme en ligne, en passant la variable “_flag_” à la valeur “_true_”:
![picture](/img/DarkHydrus/ZM.PNG){:class="img-responsive"}

Le résultat de la réponse DNS de la part du serveur de contrôle est ensuite stockée, de façon à transmettre des ordres au malware.
