---
layout: post
title: Malware Analysis - IcedID dropper & banker
categories: MalwareAnalysis
---
![Intro-picture](/img/icedid/IcedID banner.jpg){:class="img-responsive"}

### Sommaire

* Introduction
* Reconnaissance
* Overview
* Analyse
  * 1) Stage 1
  * 2) Stage 2
    * A) Unpack
    * B) Elévation de privilèges
    * C) Injection sous Svchost.exe
  * 3) Stage 3
    * A) Reconstruction de l’IAT et dump du processus
    * B) Gestion des erreurs et des exceptions
    * C) Extraction des URL du serveurs de contrôle
      * 1) OSINT divorought.com
      * 2) OSINT percalabia.com
    * D) Récolte d’informations systèmes
    * E) Méthodes de persistance
    * F) Proxy local
    * G) Anti-VM et anti-debug
    * H) Exfiltration
* Indicateurs d'infection

### Introduction
L'exécutable analysé dans cet article est le suivant:
> d4abe68c54567b9db2bc35a03ae91bc9

Celui-ci est téléchargeable sur la plateforme [Malshare](https://malshare.com/sample.php?action=detail&hash=d4abe68c54567b9db2bc35a03ae91bc9)
ou sur [VirusBay](https://beta.virusbay.io/sample/browse/d4abe68c54567b9db2bc35a03ae91bc9?q=d4abe68c54567b9db2bc35a03ae91bc9)

_A la différence du précédent article sur le malware Dexter, ce sample est beaucoup plus récent (première apparition le 17 Avril 2018) et est bien plus agressif. Une grande prudence est recommandée lors du téléchargement et de la manipulation du fichier. Attention à bien exécuter le binaire dans un environnement contrôlé qui ne dispose d’aucunes passerelles vers d’autres machines. Le malware IcedID est capable de se propager au sein d’un réseau local via de simples dossiers partagés._

### Reconnaissance
[VirusTotal](https://www.virustotal.com/#/file/0ca2971ffedf0704ac5a2b6584f462ce27bac60f17888557dc8cd414558b479e/detection ) label le fichier comme étant malicieux, et plusieurs anti-virus sont capable d’identifier la famille “IcedID” :
![picture](/img/icedid/A.PNG){:class="img-responsive"}
A noter qu’un des anti-virus reconnait bien le fait que ce malware possède une capacité d’injection dans d’autres processus:
![picture](/img/icedid/B.PNG){:class="img-responsive"}
• Le binaire actuel n’est pas packé, mais celui-ci possède une section avec une très haute entropie, ce qui laisse soupçonner qu’une ressource chiffrée/packée sera extraite par la suite.

• Les chaînes de caractères présentes dans le fichier sont très banales et presques inexploitables.

• Afin d’aiguiller mon analyse, je décide de lancer le malware tout en observant les événements systèmes avec procmon, et les interactions entres processus avec procexp, afin d’identifier un premier comportement suspect. Il se trouve que dès les premières secondes, le malware lance une copie de lui même, avant de créer un processus svchost suspect:
![picture](/img/icedid/C.PNG){:class="img-responsive"}
Cette injection me sert de point de départ pour cette analyse.

### Overview

### Analyse

#### Stage 1
Le malware commence par s’injecter dans un nouveau processus au nom homonyme. Pour dumper ce processus, il suffit de surveiller les appels systèmes généralements liés à une injection en mémoire, à savoir WriteProcessMemory, WriteProcessMemory, CreateProcess et CreateProcessInternal :
![picture](/img/icedid/D.PNG){:class="img-responsive"}
Sans surprise, un nouveau processus est donc initié avec le même nom que le sample analysé:
![picture](/img/icedid/E.PNG){:class="img-responsive"}
![picture](/img/icedid/F.PNG){:class="img-responsive"}
La fonction WriteProcessMemory est ensuite utilisée pour écrire ce nouveau processus, ce qui permet d’en intercepter directement le contenu pour y observer un fichier PE:
![picture](/img/icedid/G.PNG){:class="img-responsive"}
Il ne reste qu’à dumper ce processus en traçant l’adresse mémoire où réside le contenu du futur processus (“follow in memory map”) puis d’extraire le tout (“dump memory to file”).
Avant de continuer, il est nécessaire de patcher le header du nouveau binaire obtenu de façon à faire correspondre les adresses et tailles physiques et virtuels des différentes sections pour garder le fichier au format unmaped (fichier utilisable sur le disque, à l’inverse d’un fichier maped, utilisable uniquement en mémoire):
![picture](/img/icedid/H.PNG){:class="img-responsive"}

#### Stage 2
##### A) Unpack
Comme le nom des sections obtenus plus haut le démontre, le dump du stage 2 du malware semble packé avec UPX. Malheureusement, il sera nécessaire de l’unpacker à la main:
![picture](/img/icedid/I.PNG){:class="img-responsive"}
Pour rappel, le but est ici de trouver un jmp vers une adresse mémoire lointaine pour obtenir l’EOP du stage 2 en clair. En cas de doutes, je renvois vers mon article sur [l’unpack manuel d’un sample UPX](https://guillaumeorlando.github.io/UPX-Unpack).
Le saut en question est identifiable graphiquement:
![picture](/img/icedid/J.PNG){:class="img-responsive"}
Une fois l’adresse sur laquelle pointe ce saut extraite, il ne reste qu’à en dumper le contenu. J’utilise ici le plugin pour x64dbg Scylla. Celui-ci me permet de récupérer le nouveau fichier en précisant l’EOP, et surtout de résoudre les imports du dump en reconstruisant automatiquement l’IAT:
![picture](/img/icedid/K.PNG){:class="img-responsive"}

##### B) Elévation de privilèges
Pour commencer, le malware va récupérer la version windows avec la fonction RtlGetVersion, puis celui-ci va s'informer des privilèges avec lesquels il a été lancé. Si les privilèges ne sont pas suffisants, le malware se relance avec des privilèges administrateurs via la commande “runas” :
![picture](/img/icedid/L.PNG){:class="img-responsive"}
En résulte ainsi une UAC demandant des privilèges administrateurs:
![picture](/img/icedid/M.PNG){:class="img-responsive"}

##### C) Injection sous Svchost.exe
![picture](/img/icedid/HookExplained.PNG){:class="img-responsive"}
Afin de s’injecter dans le processus svchost.exe, IcedID va placer un hook sur la fonction RtlExitUserProcess. Dans un premier temps, un buffer contenant la suite du code malicieux est extrait en mémoire.

La fonction RtlExitUserProcess est hookée, afin de modifier le code de la fonction, et d’y ajouter une instruction jmp. Ce saut est à destination de l’espace mémoire contenant le contenu du buffer extrait à l’étape précédente:
![picture](/img/icedid/hookbeforeafter.PNG){:class="img-responsive"}
Par la suite, la fonction CreateProcess est appelée avec comme unique argument, svchost.exe. L’auteur du malware à ici ajoutée une pointe d’obfuscation en construisant la chaine de caractère “svchost” de manière dynamique, et en poussant les lettres unes par unes sur la stack:
![picture](/img/icedid/P.PNG){:class="img-responsive"}
Lorsqu’un processus svchost est créé sans arguments supplémentaires, celui-ci se ferme automatiquement. C’est ici le cas, et la fonction NtTerminateProcess est appelé par l’OS.
NtTerminateProcess appel lui même RtlExitUserProcess, ce qui déclenche l’exécution du code malicieux, puisque la fonction a été altérée juste auparavant.

Par cette méthode, le processus svchost est maintenu en vie, et celui-ci fait désormais tourner le code malveillant injecté par le malware:
![picture](/img/icedid/Q.PNG){:class="img-responsive"}
Pour intercepter le code injecté dans le processus svchost.exe, il faut donc attacher le nouveau processus à un debugger lorsque celui-ci est créé, puis surveiller les appels de l’API RtlExitUserProcess afin de récupérer l'adresse du jmp injecté à la suite du hook. A cette adresse mémoire se situe le coeur du malware IcedID.

#### Stage 3
##### A) Reconstruction de l’IAT et dump du processus
Afin de pouvoir effectuer une analyse statique du code injecté dans le processus svchost.exe, il est nécessaire d’en récupérer une copie. Mais un problème se pose : les appels systèmes ne sont pas résolus naturellement dans la section injectée:
![picture](/img/icedid/iat_before.PNG){:class="img-responsive"}
Les calls sont faits sur des pointeurs amenant à une section mémoire vide:
![picture](/img/icedid/S.PNG){:class="img-responsive"}
L’IAT va donc être construite dynamiquement dans cette section mémoire. En exécutant la première fonction à disposition, les appels systèmes sont en partie résolues:
![picture](/img/icedid/T.PNG){:class="img-responsive"}
Enfin, puisque certains calls sont résolus en pointant sur d’autres sections mémoires éloignées, il va être nécessaire de dumper le code injecté ainsi que la section distance contenant quelques fonctions supplémentaires.

Pour analyser statiquement le code injecté, il faudra donc ouvrir les deux dump sous IDA pour résoudre quelques calls systèmes.
Enfin, pour terminer, des outils comme APIscout peuvent êtres utiles pour résoudres d’autres appels systèmes et compléter le dump du code injecté, et faciliter le travail d’analyse du malware.

##### B) Gestion des erreurs et des exceptions
Afin de rester incognito sur le système infecté, IcedID commence par cacher les erreurs systèmes pouvants être affichées à l’utilisateur. Lorsque la fonction SetErrorMode est appelée avec l’argument 0x8007h, tous les messages d’erreurs applicatifs restent cachés:
![picture](/img/icedid/U.PNG){:class="img-responsive"}
En cas de crash ou de problèmes causé par le malware, l’utilisateur ne sera pas averti. Plus précisément, les modes suivants sont activés:
![picture](/img/icedid/tab1.PNG){:class="img-responsive"}

##### C) Extraction des URL du serveurs de contrôle
Les URL des serveurs de contrôle sont ensuites dynamiquement extraites de la configuration du malware par une fonction de désobfuscation:
![picture](/img/icedid/V.PNG){:class="img-responsive"}
Ce sample est capable d’extraire deux URL de sa configuration:
![picture](/img/icedid/tab2.PNG){:class="img-responsive"}
###### 1) OSINT divorought.com
A l’heure actuel, l’adresse n’est plus attribuée.

En revanche, l’URL ayant été active mi-avril 2018, possède un passif malicieux:
![picture](/img/icedid/W.PNG){:class="img-responsive"}
Celle-ci est bien liée à la campagne de spread du malware IcedID, mais aussi Emotet et Hancitor-malspam.

L’enregistrement du nom de domaine à été fait avec les informations suivantes:
![picture](/img/icedid/X.PNG){:class="img-responsive"}
Cette adresse mail a servi pour enregistrer de très nombreux nom de domaines, très souvent lié à des activités malicieuses en lien avec IcedID ou Emotet.

###### 2) OSINT percalabia.com
Sans grande surprise, ce nom de domaine à lui aussi été enregistré avec le même compte que l’entrée DNS précédente:
![picture](/img/icedid/Y.PNG){:class="img-responsive"}
Cette adresse est elle aussi liée à la campagne IcedID et Emotet.

Les deux URL extraites de la configuration sont bien liées entres elles, et servent de point de contrôle pour l’opérateur derrière IcedID.

##### D) Récolte d’informations systèmes
Comme tout trojan qui se respecte, IcedID chercher à récolter des informations sur la machine infectée, mais ici, de manière parcimonieuse.
Dans un premier temps, le SID (Security Identifier) est récupéré, ainsi que le nom de la machine et de la session:
![picture](/img/icedid/Z.PNG){:class="img-responsive"}
La version Windows est ensuite récupérée à l’aide de la fonction RtlGetVersion:
![picture](/img/icedid/ZA.PNG){:class="img-responsive"}
Des informations sur l’architecture de la machine et sur le token de sécurité sont elles aussi récoltées:
![picture](/img/icedid/ZB.PNG){:class="img-responsive"}
Pour finir, l’adresse du contrôleur de domaine (s’il existe), et retrouvée avec la fonction NetGetDCName:
![picture](/img/icedid/ZC.PNG){:class="img-responsive"}

##### E) Méthodes de persistance
La technique employée par IcedID pour survivre au reboot de la machine est très sommaire, mais terriblement efficace. Un faux service de mise à jour est ajoutée dans le planificateur de tâche, avec une exécution prévu à chaques ouverture de session sur le système. Ce service de mise à jour est une simple copie du stage 2 du malware.
IcedID commence ici par générer un nom aléatoire qui servira à l’exécutable appelé par le planificateur de tâche:
![picture](/img/icedid/ZD.PNG){:class="img-responsive"}
Dans mon cas, le fichier exécutable s’appel “denrmircp.exe”.

Ensuite, le malware cherche un dossier déjà présent sous \\AppData\\Local\\, afin d’y placer le nouveau exécutable. Un dossier choisi au hasard va héberger cette copie du malware:
 Le fait de générer un nom aléatoirement et de placer la copie dans un dossier déjà existant permet de semer la confusion si un utilisateur tombe sur le fichier malicieux.

La tâche planifiée est ensuite créée, via l’utilisateur système actuel, avec le nom “Update” et la description “Check Update”:
![picture](/img/icedid/ZE.PNG){:class="img-responsive"}

Pour vérifier si la méthode de persistance doit être exécutée (dans le cas ou le système serait déjà infecté par exemple, le malware n’utilisant pas de mutex), une comparaison est faite sur le nom du fichier depuis lequel le processus a été lancé et sur le nom de fichier généré pour être utilisé via le planificateur de tâche. De cette façon, le malware est capable de déterminer s’il est lancé suite au planificateur de tâche, ou s’il s’agit de l’étape initiale de l’infection:
![picture](/img/icedid/ZF.PNG){:class="img-responsive"}

##### F) Proxy local
Afin d’intercepter et d’altérer les données web de la machine infectée, IcedID met en place un proxy sur la boucle local. Afin de rester discret, le malware extrait un certificat PCA (Primary Certificate Authority) de sa configuration. Celui-ci permet de signer les pages HTTPS interceptées avec une infinitée de certificats produit par la propre autorité de certification du malware.

Le certificat est construit dynamiquement, dans un fichier créé sous \\AppData\\Local\\Temp\\[A-Z0-9]{8}.tmp:
![picture](/img/icedid/ZG.PNG){:class="img-responsive"}
Il s’agit d’un certificat Verisign datant de 2006:
![picture](/img/icedid/tab3.PNG){:class="img-responsive"}
L’entièreté du certificat est ensuite généré, et celui-ci est ajouté à la liste des certificats Windows:
![picture](/img/icedid/ZH.PNG){:class="img-responsive"}
Par la suite, le proxy local est mis en place:
![picture](/img/icedid/ZI.PNG){:class="img-responsive"}
![picture](/img/icedid/ZJ.PNG){:class="img-responsive"}
![picture](/img/icedid/ZK.PNG){:class="img-responsive"}
Le proxy est ainsi initié sur le protocol TCP, sur l’adresse local 127.0.0.1, et en utilisant le port 5000:
![picture](/img/icedid/ZL.PNG){:class="img-responsive"}
Une liste de domaine à spoofer est extraite de la configuration puis obfusquée dans une clé de registre sous “\SOFTWARE\Classes\CLSID\{B2C9B96F-A3E9-0806-9617-338F1ECD9918}”. Le malware est ainsi prêt à récolter des identifiants et mots de passes d’institutions bancaires.

##### G) Anti-VM et anti-debug
Étrangement, le malware ne cherche pas à détecter les environnements virtuels de manière agressive et préventive, mais juste afin de faire remonter l’information au serveur de contrôle. La détection d’une machine virtuelle n'entraîne pas le crash du malware ou une quelconque perte d’informations. Deux principales méthodes sont utilisées.

• L’instruction CPUID permet de retourner des informations sur le processeur:
![picture](/img/icedid/ZM.PNG){:class="img-responsive"}
En appelant l’instruction CPUID avec la valeur 40000000 dans le registre EAX, des informations sur la technologie de virtualisation peuvent être extraites. La fonction est construite de la sorte:
![picture](/img/icedid/vm_guess.PNG){:class="img-responsive"}
En fonction de la technologie de virtualisation trouvée (ou non), une valeure est attribuée à la machine. De 0x0 à 0x4, celà signifie que le malware n’est pas dans une machine virtuelle, de 0x4 à 0x7 qu’il est dans une VM VMware, et ainsi de suite…

• L’instruction RDTSC retourne un timestamp relatif au processeur. En appelant cette instruction deux fois, mais en laissant des instructions entre, il est possible de comparer le temps mis pour exécuter quelques instructions, et ainsi déterminer si le code est exécuté à la main, au travers d’un débugger:
![picture](/img/icedid/ZN.PNG){:class="img-responsive"}
Les instructions RDTSC sont placés “stratégiquement” autours de l’instruction CPUID, afin d’empêcher la modification de la valeure retournée, mais ceci est inutile puisque l’information peut être dynamiquement modifiée plus tard.

##### H) Exfiltration
Un thread responsable des capacitées d’exfiltration réseau du malware est créé:
![picture](/img/icedid/ZO.PNG){:class="img-responsive"}
Afin de préparer la première communication avec le serveur de contrôle, les informations nécessaires pour identifier la machine sont extraites. Ces informations concernent le nom de la machine, le groupe de travail et l’utilisateur de la session active :
![picture](/img/icedid/ZP.PNG){:class="img-responsive"}
![picture](/img/icedid/ZQ.PNG){:class="img-responsive"}
![picture](/img/icedid/ZR.PNG){:class="img-responsive"}
Ces informations sont encodées au format URL:
![picture](/img/icedid/ZS.PNG){:class="img-responsive"}
![picture](/img/icedid/ZT.PNG){:class="img-responsive"}
![picture](/img/icedid/ZU.PNG){:class="img-responsive"}
Une requête POST est ensuite créé avec les donnée récupérées (en plus de la version Windows). Une lettre est associé à chacunes des informations:
![picture](/img/icedid/ZV.PNG){:class="img-responsive"}
Le tout en donc passé en paramètre de la requête POST suivante:
[picture](/img/icedid/ZW.PNG){:class="img-responsive"}
Pour terminer, le malware envoi la requête à ses serveurs de contrôles.

Le serveur de contrôle est désormais capable de répondre et d’envoyer des instructions précises au malware.
IcedID va ensuite télécharger des modules supplémentaire lorsque le C2 lui répondra avec des instructions spécifiques. Le sample actuel n’a plus de serveur de contrôle online, il m’est donc impossible d’analyser les modules de IcedID.
Le malware entre ensuite en sommeil, à moins de recevoir de nouvelles instructions, ou s’il dispose d’informations à exfiltrer.

### Indicateurs d'infection
Hash du binaire stage 1 (Injector) : _d4abe68c54567b9db2bc35a03ae91bc9_
Hash du binaire stage 2 (UPX unpacked) : _4ad54337918cd6e6c77eae69f68da239_
Serveur de contrôle : _46.148.26.106 - divorought.com_
Serveur de contrôle : _5.187.0.158 - percalabia.com_
Requête Http : _POST */*.php?a=[0-9]&b=[A-Z0-9]{17}&d=[0-9]&f=[0-9]&g=[0-9]_
Fichier système : _C:\Users\%USERNAME%\AppData\Local\%RANDOM_DIR%\[a-z]{9}.exe_
Certificat VériSign: _C:\Users\%USERNAME%\AppData\Local\Temp\[A-Z0-9]{8}.tmp_
Tâche planifiée : _“Update”, “Ready”, “A l’ouverture de la session”, “Démarrer un programme”, “C:\Users\%USERNAME%\AppData\Local\%RANDOM_DIR%\[a-z]{9}.exe”_

[picture](/img/icedid/tab4.PNG){:class="img-responsive"}

[picture](/img/icedid/tab5.PNG){:class="img-responsive"}

[picture](/img/icedid/tab6.PNG){:class="img-responsive"}
