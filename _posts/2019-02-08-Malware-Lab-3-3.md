---
layout: post
title: Practical Malware Analysis - Lab 03x3
categories: MalwareAnalysis
---
### Lab 3-3 (Lab03-03.exe) / (Lab12-2.exe)
> 1 - What do you notice when monitoring this malware with Process monitor ?

Au lancement du binaire, une nouvelle instance du processus “_svchost.exe_” est créé, en tant que processus enfant du malware:

![PMA-A](/img/PMA/chap3/03/A.png){:class="img-responsive"}

Puis, le processus parent du malware est terminé, laissant le processus enfant seul:

![PMA-A](/img/PMA/chap3/03/B.png){:class="img-responsive"}

Ce comportement est typique d’une injection de contenu en mémoire.

>2 - Can you identify any live memory indicators ?

Le nouveau processus svchost est détaché des processus svchost légitimes, et son PID est logiquement plus haut que les autres processus:

![PMA-A](/img/PMA/chap3/03/C.png){:class="img-responsive"}

De manière plus précise, en observant le processus parent des svchost.exe, celui démarré par le malware possède de simples droits utilisateurs, et n’a pas été initié par services.exe (à gauche un processus svchost malicieux, à droite un processus svchost légitime):

![PMA-A](/img/PMA/chap3/03/D.png){:class="img-responsive"}

> 3 - What are the malware’s host-based indicator ?

Le malware drop un fichier de log sur le bureau, au nom de “_practicalmalwareanalysis.log_”.

> 4 - What is the purpose of this program ?

Le programme injecte un keylogger dans la fausse instance svchost. En effet, le fichier trouvé précédemment contient la liste des programmes avec lesquels l’utilisateur interagit ainsi que les frappes claviers effectuées:

![PMA-A](/img/PMA/chap3/03/E.PNG){:class="img-responsive"}

### Analyse complète:
### Stage 1 (injector):
Puisque le premier stage du malware va injecter du contenu malveillant dans un processus ‘_svchost.exe_’, le chemin relatif de ce processus est construit dynamiquement en mémoire:

![PMA-A](/img/PMA/chap3/03/F.png){:class="img-responsive"}

Le contenu à injecter en mémoire est ensuite récupéré depuis un ressource interne au malware. La ressource est située dans l’arborescence “_UNICODE/LOCALIZATION_”. La ressource est chargée en mémoire à l’aide des fonctions [LoadResource](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadresource) et [LockResource](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-lockresource):

![PMA-A](/img/PMA/chap3/03/G.PNG){:class="img-responsive"}

[LoadResource](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadresource) va retourner un handler vers la ressource spécifiée, et [LockResource](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-lockresource) un pointeur vers l’espace mémoire contenant la ressource.
Cette dernière est chiffrée / obfusqué de façon à ce que le contenu ne soit pas lisible pour le moment:

![PMA-A](/img/PMA/chap3/03/H.PNG){:class="img-responsive"}

Le déchiffrement de la ressource va donc se faire en mémoire.
Une portion mémoire suffisamment grande pour l’accueillir est donc allouée avec la fonction [Virtualalloc](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) puis [memcpy](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/memcpy-wmemcpy?view=vs-2019):

![PMA-A](/img/PMA/chap3/03/I.PNG){:class="img-responsive"}

Enfin, la copie mémoire de la ressource est déchiffrée avec un simple [xor](http://www.xcprod.com/titan/XCSB-DOC/binary_xor.html), bytes par bytes:

![PMA-A](/img/PMA/chap3/03/J.PNG){:class="img-responsive"}

La clé permettant de déchiffrer le [xor](http://www.xcprod.com/titan/XCSB-DOC/binary_xor.html) est “_0x41_”.

Il est maintenant possible de dumper le contenu du payload déchiffré via un débugger. J’ai personnellement écrit un script python capable d’extraire la ressource du malware et de la déchiffrer en mémoire, avant d’écrire le résultat dans un nouvel exécutable:
![PMA-A](/img/PMA/chap3/03/K.PNG){:class="img-responsive"}

Le script, bien que mal optimisé, est disponible à cet adresse:
[https://github.com/GuillaumeOrlando/MalwareAnalysisArtifacts](https://github.com/GuillaumeOrlando/MalwareAnalysisArtifacts)

Le scan VirusTotal du dump est le suivant:
[https://www.virustotal.com/gui[...]](https://www.virustotal.com/gui/file/9b683d2fda7ca7adcc043e4412271009a0e115ca55f9a718c385a3f46b57ae6b/detection)

La fonction d’injection en mémoire est ensuite appelée, et prenant comme argument un pointeur vers l’espace mémoire contenant le payload à injecter, et le nom du processus cible dans lequel injecter le contenu malicieu:

![PMA-A](/img/PMA/chap3/03/L.PNG){:class="img-responsive"}

Le processus vierge svchost.exe est créé:

![PMA-A](/img/PMA/chap3/03/M.PNG){:class="img-responsive"}

Le processus est créé dans un état suspendu (“_CreationFlag_” à 0x00000004) de façon à permettre au malware d'interagir avec:

![PMA-A](/img/PMA/chap3/03/N.PNG){:class="img-responsive"}

Le contexte du thread est récupéré par la fonction [GetThreadContext](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext), puis, à l’aide de la fonction [ZwUnmapViewOfSection](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-zwunmapviewofsection), le contenu du processus cible est nettoyé:

![PMA-A](/img/PMA/chap3/03/S.PNG){:class="img-responsive"}

![PMA-A](/img/PMA/chap3/03/T.PNG){:class="img-responsive"}

Une fois l’espace mémoire nettoyé, un nouvel section mémoire est attribué avec [VirtualAlloc](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc):

![PMA-A](/img/PMA/chap3/03/U.PNG){:class="img-responsive"}

Enfin, la fonction [WriteProcessMemory](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory) va permettre d’écrire unes-à-unes les sections (_.text_, _.rdata_ et _.data_) du payload dans le processus svchost.exe:

![PMA-A](/img/PMA/chap3/03/V.PNG){:class="img-responsive"}

L’état suspendu du processus est levé, pour permettre au keylogger de fonctionner:

![PMA-A](/img/PMA/chap3/03/W.PNG){:class="img-responsive"}

Le malware se termine à la suite, après une période de sommeil brève, pour laisser place au keylogger en mémoire:

![PMA-A](/img/PMA/chap3/03/X.PNG){:class="img-responsive"}

### Stage2 (payload):
Le fichier extrait du processus svchost.exe est un keylogger qui va monitorer tous les événements systèmes relatif aux frappes claviers via la fonction [SetWindowsHookA](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa). La fonction prend plusieurs arguments, dont “_idHook_” qui permet de cibler uniquement les événements claviers (via l’argument _0x13_), et “_lpfn_” qui pointe vers le code à exécuter dès qu’un événement est intercepté par le hook (ici, la fonction “_hook_procedure_”):

![PMA-A](/img/PMA/chap3/03/Y.PNG){:class="img-responsive"}

Si aucun événement clavier n’est retourné par le système d’exploitation, le keylogger se contente de récupérer les messages suivants, jusqu'à en trouver un intéressant:

![PMA-A](/img/PMA/chap3/03/Z.PNG){:class="img-responsive"}

Dans le cas où une frappe clavier est détectée, la procédure liée au coeur du keylogger est appelée:

![PMA-A](/img/PMA/chap3/03/ZA.PNG){:class="img-responsive"}

Le fichier dans lequel les frappes claviers vont êtres sauvegardés est créé dans un premier temps:

![PMA-A](/img/PMA/chap3/03/ZB.PNG){:class="img-responsive"}

Le nom du processus avec lequel l’utilisateur interagit est récupéré avec les fonctions [GetForegroundWindows](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getforegroundwindow) (retourne un handler vers la fenêtre au premier plan) et [GetWindowsTextA](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowtexta) (retourne le titre de la fenêtre, en fonction du handler spécifié):

![PMA-A](/img/PMA/chap3/03/ZC.PNG){:class="img-responsive"}

Le nom de la fenêtre en question est ajoutée à la suite du fichier de log, au sein d’une balise “_[Window: <title>]_”:
  
![PMA-A](/img/PMA/chap3/03/ZD.png){:class="img-responsive"}

Le résultat est le suivant:

![PMA-A](/img/PMA/chap3/03/ZE.PNG){:class="img-responsive"}

La touche clavier ayant déclenchée l'événement est, pour finir, écrite au sein du fichier de log. Si la touche est une simple touche alphabétique, celle-ci est ajoutée telle-quelle à la suite du fichier. Si la touche correspond à une action particulière (i.e: une barre d’espace, un “_entrer_”, un “_shift_”, etc …) ou à un chiffre, un switch de 19 valeurs est appliquée de façon à déterminer et formater l’entrée qui sera ajoutée au fichier de log:

![PMA-A](/img/PMA/chap3/03/ZF.png){:class="img-responsive"}

Par exemple, le code responsable d’ajouter la touche _“shift”_ au fichier de log est le suivant:

![PMA-A](/img/PMA/chap3/03/ZG.PNG){:class="img-responsive"}

Le résultat est ensuite appliqué au fichier de log:

![PMA-A](/img/PMA/chap3/03/ZH.PNG){:class="img-responsive"}

Le keylogger boucle sur cette suite d’actions, à partir du moment ou une frappe clavier est détectée.
À noter que la malware ne possède pas de méthode de persistance, ni de technique l'exfiltration de données.

### Ressources:
* [https://0x00sec.org/t/windows-keylogging-part-i/99](https://0x00sec.org/t/windows-keylogging-part-i/99)
* [https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process](https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process)
