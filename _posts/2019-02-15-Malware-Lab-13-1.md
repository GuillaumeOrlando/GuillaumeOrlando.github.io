---
layout: post
title: Practical Malware Analysis - Lab 13x1
categories: MalwareAnalysis
---
### Lab 3-3 (Lab13-01.exe)
>1 - Compare the strings in the malware (from the output of the strings command) with the information available via dynamic analysis. Based on this comparison, which elements might be encoded?

Une ressource intégrée au malware semble lourdement obfusqué en analyse dynamique, mais se révèle être en fait une adresse web que le malware va certainement visiter par la suite:

![PMA-A](/img/PMA/chap13/01/A.PNG){:class="img-responsive"}

![PMA-A](/img/PMA/chap13/01/B.PNG){:class="img-responsive"}

>2 - Use IDA Pro to look for potential encoding by searching for the string xor. What type of encoding do you find?

En cherchant la liste des instructions xor du programme (_sous IDA Pro: search -> text -> find all occurrences -> xor_), il s’avère que la plupart d’entre elles ne servent qu’à rapidement réinitialiser des registres (_i.e: xor eax, eax_):

![PMA-A](/img/PMA/chap13/01/CC.PNG){:class="img-responsive"}

À y regarder de plus près, une instruction est primordiale pour l’analyse: l’instruction _0x004011B8_. Celle-ci est typique d’un single byte xor. Et en l’observant précisément, c’est effectivement le cas:

![PMA-A](/img/PMA/chap13/01/D.PNG){:class="img-responsive"}

>3 - What is the key used for encoding and what content does it encode?

D’après les trouvailles de la question précédente, il existe une fonction permettant de déchiffrer un contenu via une instruction xor avec la clé “_0x3B_”.

Le contenu en question est chargé depuis une ressource interne au malware:

![PMA-A](/img/PMA/chap13/01/E.PNG){:class="img-responsive"}

La ressource en question, situé dans l’arborescence “_RCData/101_”, comprend une chaine visiblement lourdement obfusquée (la même qu’en question 1):

![PMA-A](/img/PMA/chap13/01/F.PNG){:class="img-responsive"}

L’analyse dynamique du malware permet de révéler la véritable signification de la chaine de caractère :

![PMA-A](/img/PMA/chap13/01/B.PNG){:class="img-responsive"}

>4 - Use the static tools to identify any other encoding mechanisms. What do you find?

L’outil Krypto ANALyzer retourne des traces liées à un possible algorithme de conversion base64:

![PMA-A](/img/PMA/chap13/01/G.PNG){:class="img-responsive"}

DetectItEasy fournis un grah d'entropie assez élevé pour la section _.text_. Pour le reste rien de flagrant, même si le dernier pic (correspondant à la section _.rsc_, donc les ressources intégrées au binaire) met tout de même en évidence une haute entropie:

![PMA-A](/img/PMA/chap13/01/H.PNG){:class="img-responsive"}

>5 - What type of encoding is used for a portion of the network traffic sent by the malware?

Comme confirmé par les trouvailles précédentes, le malware exfiltre des données en base64, au travers d’un URL:

![PMA-A](/img/PMA/chap13/01/I.PNG){:class="img-responsive"}

>6 - Where is the Base64 function in the disassembly?

La fonction responsable de la création de la chaine en base64 est située à l’adresse _0x00401000_. En effet, cette fonction prend en argument des données potentielles à exfiltrer (ici le hostname de la machine), et utilise un index alphabétique propre à celle utilisée par l’algorithme base64 pour retourner une chaine de caractères:

![PMA-A](/img/PMA/chap13/01/J.PNG){:class="img-responsive"}

>7 - What is the maximum length of the Base64-encoded data that is sent? What is encoded?

Le contenu passé à la fonction responsable de traduire la chaine au format base64 à une longueur de 12 caractères. Le contenu passé en base64 est en fait le hostname de la machine infectée. Mais de ce hostname n’est gardé que les 12 premiers caractères. Voici l’état de la stack avant l’appel à la fonction “_strncpy_” qui va tailler la longueur du hostname à conserver:

![PMA-A](/img/PMA/chap13/01/C.PNG){:class="img-responsive"}

Le premier argument est l’adresse à laquelle la chaine retaillée va être accessible en mémoire, le second argument est l’adresse à laquelle la chaine à découper est actuellement en mémoire, et le troisième argument précise (au format hexadécimal) le nombre de caractères à conserver.

>8 - In this malware, would you ever see the padding characters (= or ==) in the Base64-encoded data?

Non, en effet, la fonction responsable de la conversion au format base64 traite les caractères 3 par 3, mais retourne des chaînes de longueur 4:

![PMA-A](/img/PMA/chap13/01/K.PNG){:class="img-responsive"}

Ainsi, la chaine exfiltrée est longue de 16 caractères au maximum. Puisque la chaine avant formatage est longue de 12 caractères, et que ce dernier est un multiple de 4, la chaine n’a pas besoin de padding.

>9 - What does this malware do?

Le malware charge une ressource intégrée et la déchiffre à l’aide d’un single byte xor:

![PMA-A](/img/PMA/chap13/01/L.PNG){:class="img-responsive"}

Cette ressource est en fait une URL “_www.practicalmalwareanalysis.com_”:

![PMA-A](/img/PMA/chap13/01/M.PNG){:class="img-responsive"}

Le malware va ensuite récupérer le hostname de la machine et convertir les 12 premiers caractères en base64:

![PMA-A](/img/PMA/chap13/01/N.PNG){:class="img-responsive"}

Une adresse sera formée entre la première URL et le contenu base64:

![PMA-A](/img/PMA/chap13/01/O.PNG){:class="img-responsive"}

Un navigateur est ensuite ouvert en direction de cette adresse, avant d’écouter une quelconque réponse du serveur web:

![PMA-A](/img/PMA/chap13/01/P.PNG){:class="img-responsive"}

Cette opération permet au malware d'exfiltrer des informations (ici le hostname de la machine) via le protocole HTTP, avant de recevoir une instruction.

Le fait de remonter le hostname de la machine permet à l’opérateur du serveur de contrôle du malware d’être notifié qu’une nouvelle victime a été infectée, et d’identifier précisément cette machine lors des prochaines interactions.
