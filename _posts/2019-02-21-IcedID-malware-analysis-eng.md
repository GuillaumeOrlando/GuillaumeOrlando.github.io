---
layout: post
title: Malware Analysis - IcedID
categories: MalwareAnalysis
---
![Intro-picture](/img/icedid/icedid_banner.jpg){:class="img-responsive"}

### Sommaire

* Introduction
* Recon
* Overview
* Analysis
  * 1) Stage 1
  * 2) Stage 2
    * A) Unpack
    * B) Privilege escalation
    * C) Svchost.exe injection
  * 3) Stage 3
    * A) IAT rebuild and process dump
    * B) Errors and exeptions handler
    * C) C2 URL extraction
      * 1) OSINT divorought.com
      * 2) OSINT percalabia.com
    * D) Information gathering
    * E) Persistence method
    * F) Local proxy
    * G) Anti-VM and anti-debug
    * H) Exfiltration
* Indicators of compromise

### Introduction
The analysed sample is the following:
> d4abe68c54567b9db2bc35a03ae91bc9

This one can be download on [Malshare](https://malshare.com/sample.php?action=detail&hash=d4abe68c54567b9db2bc35a03ae91bc9) or on [VirusBay](https://beta.virusbay.io/sample/browse/d4abe68c54567b9db2bc35a03ae91bc9?q=d4abe68c54567b9db2bc35a03ae91bc9).

_Unlike my previous blog post regarding the Dexter sample, this malware is younger (first seen the 17 April 2018) and much more aggressive. Be carrefull while downloading and manipulating this file. The binary file must be launch inside a controled environnement, with no gateway to other physical computers. IcedID is able to spread itself through shared files._

### Recon
[VirusTotal](https://www.virustotal.com/#/file/0ca2971ffedf0704ac5a2b6584f462ce27bac60f17888557dc8cd414558b479e/detection ) labeled this file as malicious, and many anti-virus are able to identify the "IcedID" malware's family :
![picture](/img/icedid/A.PNG){:class="img-responsive"}
One of the AV is even able to tell that this sample is going to inject itself into another process:
![picture](/img/icedid/B.PNG){:class="img-responsive"}
• The sample is not packed, but one of the PE section have an high entropy, which lead to the conclusion that a second ressource may be packed/cipher inside the first one.

• The strings inside the sample are ordinary, and almost useless.

• In order to start my analysis somewhere, i've launched the malware while monitoring the systems events with procmon, and while checking the process with procexp, in order to gain a first overview of what's going on with this malware. During the launch time, the malware is injected into a new copy of itself, just before seting up a suspect svchost.exe process:
![picture](/img/icedid/C.PNG){:class="img-responsive"}
This injection is my starting point.

### Overview

### Analyse

#### Stage 1
The malware begin by injecting itself into a new process that have the same name than the original malware process. In order to dump it, the [WriteProcessMemory](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-writeprocessmemory), [VirtualAlloc](https://docs.microsoft.com/fr-fr/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc), [CreateProcess](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa) and [CreateProcessInternal](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa) API need to be monitored. Those ones are the most common API related to process injection:
![picture](/img/icedid/D.PNG){:class="img-responsive"}
Without surprises, a new process is launch with the same name that the analysed sample:
![picture](/img/icedid/E.PNG){:class="img-responsive"}
![picture](/img/icedid/F.PNG){:class="img-responsive"}
The [WriteProcessMemory](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-writeprocessmemory) is then launched. This function is use to write the new process in memory, which is a way for us to dump the new process content. This dump is a valid PE file:
![picture](/img/icedid/G.PNG){:class="img-responsive"}
The dump can be extract by tracing back the memory layout where the process lives in ("follow in memory dump" under x64dbg) then extract it ("dump memory to file").
The header of the new dumped file need to be adapt by changing the virtual memory address and size to make them match with the phyical ones. By doing this, the file is going to be in an unmaped format (unmaped files can be used on a disk, where the maped format is for memory file):
![picture](/img/icedid/H.PNG){:class="img-responsive"}

#### Stage 2
##### A) Unpack
As the section's name suggest, the stage 2 dump of the malware seems pack with [UPX](https://upx.github.io/).
Unfortunately, it will be needed to unpack it by hand:
![picture](/img/icedid/I.PNG){:class="img-responsive"}
As a reminder, the goal here is to find the jmp instruction that point to a far away memory space. This memory space is going to be the EOP of the second stage of IcedID. If in doubt, i advise you to read one of my previous blog post about [manually unpack UPX file](https://guillaumeorlando.github.io/UPX-Unpack).
The relevant jmp can be found by looking at the code's graph:
![picture](/img/icedid/J.PNG){:class="img-responsive"}
Once the address of that jump extracted, the dump can be made on that content. I'm using the [Scylla](https://github.com/x64dbg/ScyllaHide) x64dbg plugin.
This plugin make life easier by allowing the recovery of the [IAT](http://sandsprite.com/CodeStuff/Understanding_imports.html) by dynamically rebuilding the API imports.

##### B) Privilege escalation
To begin with, the Windows"s version is gather with the RtlGetVersion API, then the privilege level is checked. If the privileges as not high enought, the malware re-launch itself with the "[runas](https://www.computerhope.com/runas.htm)" command:
![picture](/img/icedid/L.PNG){:class="img-responsive"}
En résulte ainsi une UAC demandant des privilèges administrateurs:
![picture](/img/icedid/M.PNG){:class="img-responsive"}

##### C) Svchost.exe injection
![picture](/img/icedid/HookExplained.jpg){:class="img-responsive"}
In order to inject itself into svchost.exe, IcedID is hooking the [RtlExitUserProcess](https://ntdllblog.wordpress.com/2016/10/12/rtlexituserprocess/) function.
First, a buffer containing the malicious code is extract in memory.

The [RtlExitUserProcess](https://ntdllblog.wordpress.com/2016/10/12/rtlexituserprocess/) function is hooked. The hook aim to modifiy the function's code by adding an jmp instruction into it. This jmp is pointing to the buffer containing the malicious code extracted at the previous step:
![picture](/img/icedid/hookbeforeafter.jpg){:class="img-responsive"}

Next, the [CreateProcess](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa) function is call with one unique argument : [svchost.exe](https://en.wikipedia.org/wiki/Svchost.exe). The malware author add a touch of obfuscation by building the svchost string by pushing the characters ones by ones on the stack:
![picture](/img/icedid/P.PNG){:class="img-responsive"}
When a svchost process is called without further arguments, this one is automatically closed by the operating system. That's what is happening here, and the [NtTerminateProcess](https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FProcess%2FNtTerminateProcess.html) is call by the OS. The [RtlExitUserProcess](https://ntdllblog.wordpress.com/2016/10/12/rtlexituserprocess/) is then call by the [NtTerminateProcess](https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FProcess%2FNtTerminateProcess.html) function. This last action lead to the execution of the malicious code, because of the jmp that have been add with the hook.

By using this method, the svchost process is kept alive, and is running the malicious code injected by the malware:
![picture](/img/icedid/Q.PNG){:class="img-responsive"}
Debuging an injected process mean attaching a debuger on it on the fly, and monitoring the [RtlExitUserProcess](https://ntdllblog.wordpress.com/2016/10/12/rtlexituserprocess/) function in order to get the address of the jmp injected by the hook. At this memory address is the core functionality of the IcedID malware.

#### Stage 3
##### A) IAT rebuild and process dump
Reversing the injected malicious code is only possible with a copy of this code. But their is an issue : the syscalls are not populated in this section:
![picture](/img/icedid/iat_before.PNG){:class="img-responsive"}
All of the calls are pointing to a nulled memory space:
![picture](/img/icedid/S.PNG){:class="img-responsive"}
The IAT may be build dynamically in this memory section. By blindly executing the first functions of the injected code, all of the syscalls are resolved by themselves:
![picture](/img/icedid/T.PNG){:class="img-responsive"}
Some of the syscalls are not populated and are pointing into another memory area. This memory space is also going to be needed while performing the static analysis.

In order to analyse the injected code, both of the memory layout will be opened in IDA.
Some tools may be handy when it come to populate syscalls, like [APIscout](https://github.com/danielplohmann/apiscout).

##### B) Errors and exeptions handler
If the malware want to stay hiden on an infected system, IcedID start by hiding the system's errors that can be display to the user. When the [SetErrorMode](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680621(v=vs.85).aspx) fucntion is call with the _0x8007h_ argument, all of the errors messages stay hide:
![picture](/img/icedid/U.PNG){:class="img-responsive"}
In case of a crash or any issues caused by the malware, the user is not going to be notified. More precisely, those mods are hide:
![picture](/img/icedid/tab1.PNG){:class="img-responsive"}

##### C) C2 URL extraction
The C2's URL are dynamically extracted from the malware's configuration by a deobfuscation function:
![picture](/img/icedid/V.PNG){:class="img-responsive"}
This sample is able to extract two URL:
![picture](/img/icedid/tab2.PNG){:class="img-responsive"}
###### 1) OSINT divorought.com
At the time of writing, this address is not alive anymore.

However, this URL was active during mid-april 2018, and had some malicious related activity:
![picture](/img/icedid/W.PNG){:class="img-responsive"}
This one is related to the IcedID campaign, the Emotet one, but also Hancitor-malspam.

The domain name recording was made with the following datas:
![picture](/img/icedid/X.PNG){:class="img-responsive"}
This mail address was used for registering a lot of domain names, that are often relted to malicious activity linked to [IcedID or Emotet](https://www.fortinet.com/blog/threat-research/icedid---trickbot--a-give-and-take-relationship.html).

###### 2) OSINT percalabia.com
Without surprises, this domain name was also regitered with the same account that the previous one:
![picture](/img/icedid/Y.PNG){:class="img-responsive"}
This address is also linked to the [IcedID and Emotet campaign](https://www.fortinet.com/blog/threat-research/icedid---trickbot--a-give-and-take-relationship.html).

Those two extracted URL are closely linked, and are used as a point of control by the IcedID operator.

##### D) Information gathering
Like every other trojan, IcedID is looking for juicy information on a newly infected computer. But here, it is done in a sparingly way.
First, the [SID](https://docs.microsoft.com/en-us/windows/desktop/secauthz/security-identifiers) (Security Identifier) is retreive, along with the computer and session's name:
![picture](/img/icedid/Z.PNG){:class="img-responsive"}
The Windows version is then gather with the help of the [RtlGetVersion](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-rtlgetversion) fucntion:
![picture](/img/icedid/ZA.PNG){:class="img-responsive"}
Some more informations related to the computer architecture and about the security token are also gathered:
![picture](/img/icedid/ZB.PNG){:class="img-responsive"}
At the end, the address of the domain controler (if their is one on the network) is found with the [NetGetDCName](https://docs.microsoft.com/en-us/windows/desktop/api/lmaccess/nf-lmaccess-netgetdcname) function:
![picture](/img/icedid/ZC.PNG){:class="img-responsive"}

##### E) Persistence method
IcedID is using a not so sophisticated technique that is highly efficient. A fake update service is add into the task scheduler. This task is triggered each time an user is logging into the system. This update service is a simple copycat of the stage 2 malware.
IcedID start by generating a random name that is going to be used for the file call by the task scheduler:
![picture](/img/icedid/ZD.PNG){:class="img-responsive"}
In my case, this file is called “denrmircp.exe”.

Then, the malware is looking for a already existent random folder under \\AppData\\Local\\. The droped file is going to be placed here, inside a random folder:

The fact that IcedID is using a random executable name and the fact that it is droped under a random existing file is increasing the confusion that a user can feel while steping into that folder and seeing the malware's executable file.

The scheduled task is then created, from the actual user's account, with the "Update" anme and "Check update" description:
![picture](/img/icedid/ZE.PNG){:class="img-responsive"}

In order to check if the persistance method should be execute or not (in the case of an already infected computer, this malware is not using any mutex system), a comparison is made between the launched file's name and the randomly generated name. If the names are matching, the malware knows that it process was launched from the task scheduler, and that it's not the initial infection step:
![picture](/img/icedid/ZF.PNG){:class="img-responsive"}

##### F) Local proxy
IcedID is acting as a man-in-the-middle proxy between each browser's requests, on the loopback interface. To keep a low profile, this sample is extracting a [PCA](https://www.websecurity.symantec.com/theme/roots) certificate (Primary Certificate Authority) from it configuration. This certificate is going to allow the malware to sign the intercepted HTTPS web requests, without notifing the user.

The certificate is dynamically build, in a file under _\\AppData\\Local\\Temp\\[A-Z0-9]{8}.tmp_:
![picture](/img/icedid/ZG.PNG){:class="img-responsive"}
It's a VeriSign certificate from 2006:
![picture](/img/icedid/tab3.PNG){:class="img-responsive"}
The content of that certificate is then generate, and this one is add into the Windows certificate store:
![picture](/img/icedid/ZH.PNG){:class="img-responsive"}
Then, the local proxy is setup:
![picture](/img/icedid/ZI.PNG){:class="img-responsive"}
![picture](/img/icedid/ZJ.PNG){:class="img-responsive"}
![picture](/img/icedid/ZK.PNG){:class="img-responsive"}
This proxy is initiate ont the TCP loopback address (127.0.0.1), port 5000:
![picture](/img/icedid/ZL.PNG){:class="img-responsive"}
An array of domain name to spoof is extracted from the configuration, then cipher and hide on a register key under _“\SOFTWARE\Classes\CLSID\{B2C9B96F-A3E9-0806-9617-338F1ECD9918}”_. The malware is now ready to gather some financial credentials.

##### G) Anti-VM and anti-debug
Oddly, this sample is not [actively looking](https://anti-reversing.com/Downloads/Anti-Reversing/The_Ultimate_Anti-Reversing_Reference.pdf) for virtualized environments. It is just checking for some debugger and VM artifacts in order to notice the C2 server, but the detection of a debugger or of a virtual macine is not going to crash the sample or leading to the loose of any kind of informations.

Two techniques are used by IcedID.

• The [CPUID](https://rayanfam.com/topics/defeating-malware-anti-vm-techniques-cpuid-based-instructions/) instruction return some data about the processor:
![picture](/img/icedid/ZM.PNG){:class="img-responsive"}
By calling it with the 40000000 value into the EAX register, some informations about the virtualization vendor can be leaked. The anti-vm function is build that way:
![picture](/img/icedid/vm_guess.jpg){:class="img-responsive"}
Based on the used technology, a value is given to the computer. From 0x0 to 0x4 for an usual computer, from 0x4 to 0x7 for a VMware machine, and so on...

• The [RDTSC](https://www.aldeid.com/wiki/RDTSC-Read-Time-Stamp-Counter) instruction return a timestamp related to the processor. By calling this instruction two time in a row, but by letting some running between, it is possible to compare the time needed to execute thoses instructions. If this time is too high, it show that he code may be run manually into a debugger.
![picture](/img/icedid/ZN.PNG){:class="img-responsive"}
The [RDTSC](https://www.aldeid.com/wiki/RDTSC-Read-Time-Stamp-Counter) instructions are strategically placed around the [CPUID](https://rayanfam.com/topics/defeating-malware-anti-vm-techniques-cpuid-based-instructions/) instruction. It prevent the analyst from changing the [CPUID](https://rayanfam.com/topics/defeating-malware-anti-vm-techniques-cpuid-based-instructions/) returned value and fooling the malware. Hopefully for us, it's useless and we can change this value later.

##### H) Exfiltration
A network related thread with some exfiltration capability is created by IcedID:
![picture](/img/icedid/ZO.PNG){:class="img-responsive"}
In order to initiate the communications with the C2 server, some needed informations are extracted. Thoses informations are related to the computer name, the workgroup and the username:
![picture](/img/icedid/ZP.PNG){:class="img-responsive"}
![picture](/img/icedid/ZQ.PNG){:class="img-responsive"}
![picture](/img/icedid/ZR.PNG){:class="img-responsive"}
Thoses are URL encoded:
![picture](/img/icedid/ZS.PNG){:class="img-responsive"}
![picture](/img/icedid/ZT.PNG){:class="img-responsive"}
![picture](/img/icedid/ZU.PNG){:class="img-responsive"}
A POST request is then created with the gathered data. A letter is associate to each one of those datas:
![picture](/img/icedid/ZV.PNG){:class="img-responsive"}
Everythong is passed as a parameter for this request:
![picture](/img/icedid/ZW.PNG){:class="img-responsive"}
At the end, everything is send to the C2 servers.

The control server is now able to answer to the malware's client and to send some precise instructions.
IcedID is then going to download some additional modules from the C2 server when asked.

The given sample does not have online C2, so i'm not able to perform any analysis on the external IcedID modules.

The instructions requested by the control server are the following:
![picture](/img/icedid/tab7.PNG){:class="img-responsive"}
![picture](/img/icedid/tab8.PNG){:class="img-responsive"}

The malware enter in sleep mode, while listening for instruction coming from the C2 server, or for any stolen credentials to exfiltrate.

### Indicateurs d'infection
Hash du binaire stage 1 (Injector) : _d4abe68c54567b9db2bc35a03ae91bc9_

Hash du binaire stage 2 (UPX unpacked) : _4ad54337918cd6e6c77eae69f68da239_

C2 server : _46.148.26.106 - divorought.com_

C2 server : _5.187.0.158 - percalabia.com_

Http request : _POST */*.php?a=[0-9]&b=[A-Z0-9]{17}&d=[0-9]&f=[0-9]&g=[0-9]_

Filesystem : _C:\Users\%USERNAME%\AppData\Local\%RANDOM_DIR%\[a-z]{9}.exe_

VeriSign certificate : _C:\Users\%USERNAME%\AppData\Local\Temp\\[A-Z0-9]{8}.tmp_

Sheduled task : _“Update”, “Ready”, “session opening”, “launch a programm”, “C:\Users\%USERNAME%\AppData\Local\%RANDOM_DIR%\\[a-z]{9}.exe”_


![picture](/img/icedid/tab4.PNG){:class="img-responsive"}

![picture](/img/icedid/tab5.PNG){:class="img-responsive"}

![picture](/img/icedid/tab6.PNG){:class="img-responsive"}
