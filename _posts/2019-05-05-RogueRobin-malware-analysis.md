---
layout: post
title: Malware Analysis - RogueRobin
categories: MalwareAnalysis
---
![Intro-picture](/img/DarkHydrus/darkhydrus_banner.jpg){:class="img-responsive"}

### Sommaire

* Introduction
* Reconnaissance
* DarkHydrus APT
* Analysis
  * A) Anti-VM et anti-debug
  * B) Méthodes de persistance
  * C) Exfiltration d’informations
    * 1) Principe de l’exfiltration DNS
    * 2) Exfiltration
  * D) Récolte d’informations systèmes
  * E) C2 Instruction handler
* Indicateurs d’infection

### Introduction
Le sample analysé possède le hash suivant:
> 2f22d521a1945d02380057a636e1032b

Le sample est téléchargeable sur [VirusBay](https://beta.virusbay.io/sample/browse/2f22d521a1945d02380057a636e1032b).

_Disclaimer habituel: le sample est en théorie inoffensif puisque les serveurs de contrôles n’existent plus, et que le malware n’a pas de potentiel destructeur sur un système infecté, mais une grande prudence reste recommandée lors de la manipulation du fichier._

### Reconnaissance
Le sample reste encore assez discret, sachant que celui-ci date déjà de plusieurs mois à l’heure de l’écriture du présent article, d'après [VirusTotal](https://www.virustotal.com/#/file/6c014eddb7622e5e48c3e9d10a6ebaa02b2fe7b3318ab4f2d4daf1a619ed913c):
![picture](/img/DarkHydrus/0.PNG){:class="img-responsive"}

Mention spéciale pour les antivirus ClamAV, Microsoft-Defender et Ikarus qui ont tous trois détectés précisément le malware:
![picture](/img/DarkHydrus/01.PNG){:class="img-responsive"}
![picture](/img/DarkHydrus/02.PNG){:class="img-responsive"}
![picture](/img/DarkHydrus/03.PNG){:class="img-responsive"}

Le binaire ne semble pas packé au vu de l’entropie du fichier:
![picture](/img/DarkHydrus/B.PNG){:class="img-responsive"}

Point positif pour l’analyse, le malware a été écrit en dans un langage [.Net](https://fr.wikipedia.org/wiki/Microsoft_.NET) (dans le cas présent en C#):
![picture](/img/DarkHydrus/A.PNG){:class="img-responsive"}
L’avantage d’un malware écrit dans un langage [.Net](https://fr.wikipedia.org/wiki/Microsoft_.NET) réside dans le fait que ce langage n’est pas compilé, et peut donc être facilement être reverse. Il est possible de retrouver le code source original du programme.

Enfin, le malware n’est ni packé ni obfusqué, ce qui fait que les chaînes de caractères du binaire sont visibles en clair. Ces chaînes permettent de grignoter quelques informations sur les fonctionnalités du malware avant d’entamer l’analyse, mais rien de bien important ou de décisif dans le cas présent.

### DarkHydrus APT
Le malware [RogueRobin](https://malpedia.caad.fkie.fraunhofer.de/details/ps1.roguerobin) est attribué à un groupe émergent appelé [DarkHydrus](https://attack.mitre.org/groups/G0079/). Ce groupe, apparu pour la première fois en août 2018, possède deux campagnes malveillantes à son actif.

[La première](https://www.cybersecurity-review.com/news-august-2018/new-actor-darkhydrus-targets-middle-east-with-open-source-phishing/) réside sur l’outil open-source [Phishery](https://github.com/ryhanson/phishery), et vise à dérober des identifiants d’entités gouvernementales du moyen orient, via des documents Words malveillants.

[La deuxième campagne](https://www.cybersecurity-review.com/news-january-2019/darkhydrus-abuses-google-drive-to-spread-roguerobin-trojan/) active du groupe met en avant le malware qui fait l’objet de l’analyse présente. Celle-ci cible des groupes politiques actifs au moyen orient, et date de janvier 2019. Le malware étudié s’inscrit donc dans des objectifs géopolitiques, et le groupe [DarkHydrus](https://attack.mitre.org/groups/G0079/) risque de nouveau de faire parler de lui dans un futur proche.

### Analysis
### A) Anti-VM et anti-debug
Avant toute action, le malware commence par chercher à détecter si l'environnement d’exécution est compromis, à savoir s‘il s’agit d’une machine virtuelle d’analyse.

En premier lieu, c’est via le serial-number du BIOS de la machine, que la malware va chercher à détecter les machines virtuelles.

Le malware se base ici sur des commandes powershell externes pour toute la phase de détection de l’environnement. Dans le cas où l’une des compagnies de virtualisation ([VmWare](https://www.vmware.com/), [VirtualBox](https://www.virtualbox.org/wiki/Downloads), [BOSH](https://www.bosh.io/docs/), [Qemu](https://www.qemu.org/) ou [Xen](https://xenproject.org/)) est détectée, l'exécution du programme est immédiatement arrêtée:
![picture](/img/DarkHydrus/M.PNG){:class="img-responsive"}

C’est ensuite au tour du label du fabricant et du modèle de la machine que la détection d’une VM tentera d’être faite, via la commande powershell “gwmi win32_computersystem”:
![picture](/img/DarkHydrus/N.PNG){:class="img-responsive"}

Sur une machine VmWare, le résultat est le suivant par défaut:
![picture](/img/DarkHydrus/O.PNG){:class="img-responsive"}

Puis, c'est la quantité de mémoire vive disponible qui est scannée par le malware. Si cette quantité n'excède pas les 3Go, le flux d'exécution est stoppé. Bien souvent, les machines virtuelles d’analyse ou les sandbox n’ont pas besoin de beaucoup de performances, et puisque aujourd'hui, il est rare de trouver des machines ayant moins de 3Go de RAM, cette vérification est pertinente:
![picture](/img/DarkHydrus/P.PNG){:class="img-responsive"}
(_La variable ‘ulong’ = 2900000000u’_)

Pour continuer, le même type de vérification est fait sur le nombre de coeurs du processeur de la machine. Si la machine possède un unique coeur, celle-ci est considérée comme suspecte:
![picture](/img/DarkHydrus/Q.PNG){:class="img-responsive"}

C’est ensuite via les noms d’éditeurs relatifs aux processus en cours que le malware va essayer d’éviter l'analyse. Si un des processus provient de la suite [Sysinternals](https://docs.microsoft.com/en-us/sysinternals/) ([procmon](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) et [procexp](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer) par exemple) ou de l’éditeur [Wireshark](https://www.wireshark.org/), le malware se ferme:
![picture](/img/DarkHydrus/R.PNG){:class="img-responsive"}

Pour terminer, le malware vérifie si un [débugger](https://docs.microsoft.com/en-us/windows/desktop/api/debugapi/nf-debugapi-isdebuggerpresent) est attaché au processus:
![picture](/img/DarkHydrus/S.PNG){:class="img-responsive"}

Cette dernière vérification clôt la liste des techniques anti-analyses utilisées par le malware RogueRobin.

### B) Méthodes de persistance
De façon à passer inaperçu sur le système infecté, RogueRobinse copie dans le répertoire _AppData_, sous le nom ‘_OneDrive.exe_’, afin de ne pas éveiller les soupçons.
![picture](/img/DarkHydrus/T.PNG){:class="img-responsive"}
![picture](/img/DarkHydrus/U.PNG){:class="img-responsive"}

Pour survivre à un redémarrage de la machine, le binaire malveillant est ajouté au dossier contenant les exécutables à démarrer au lancement de la session, en créant un raccourci depuis le fichier ‘_OneDrive.exe_’ précédent:
![picture](/img/DarkHydrus/W.PNG){:class="img-responsive"}
![picture](/img/DarkHydrus/V.PNG){:class="img-responsive"}

### C) Exfiltration d’informations
Afin de se présenter aux serveurs de contrôles du malware, RogueRobin commence par extraire l’ID du processus malveillant avec la fonction _Process.GetCurrentProcess().Id_:
![picture](/img/DarkHydrus/X.PNG){:class="img-responsive"}

Dans mon cas, l’identifiant retourné par la fonction est _3856_.
Cet identifiant est converti en une chaine de caractère via une fonction qui attribue linéairement une lettre pour chaque chiffre du PID:
![picture](/img/DarkHydrus/Y.PNG){:class="img-responsive"}

La chaine obtenue dans mon cas est donc “_kpmn_”. A cette chaine de caractère s’ajoute la lettre “_a_” en début de chaine, et la lettre “_c_” en fin de chaine. La chaine finale devient donc “_akpmnc_”:
![picture](/img/DarkHydrus/Z.PNG){:class="img-responsive"}

Cette chaine sera désormais l’identifiant de la machine infectée. Afin de notifier le serveur de contrôle qu’une nouvelle machine est infectée, le malware va chercher à exfiltrer cet identifiant. La particularité du sample RogueRobin réside dans cette fonction d’exfiltration qui ne se fait pas via un simple flux TCP HTTP / HTTPS, mais via un abus du [protocole DNS](https://tools.ietf.org/html/rfc1034).

### 1) Principe de l’exfiltration DNS
L’exfiltration via un tunnel DNS consiste à extraire de l’information en abusant du protocole DNS. Le protocole DNS fonctionne sur un système décentralisé, permettant de retourner l’adresse IP d’un serveur en fonction de son [FQDN](https://en.wikipedia.org/wiki/Fully_qualified_domain_name). Pour convertir l’URL  “_www.exemple.com_” en une adresse IP, la machine source va interroger un des serveurs DNS principaux ([Top-Level Domain](https://en.wikipedia.org/wiki/Top-level_domain), ou TLD), en lui demandant l’adresse du serveur DNS responsable de la zone “_.com_”. Celui-ci retournera l’adresse demandé. Le client va ensuite demander l’adresse du serveur DNS responsable de la zone “_exemple.com_”. Enfin, c’est l’adresse du serveur “_www_” qui est demandée au DNS de la zone “_exemple.com_”.
De cette façon, un client est capable de traduire une URL en une IP.

[L'exfiltration DNS](https://blogs.akamai.com/2017/09/introduction-to-dns-data-exfiltration.html) consiste à interroger un serveur DNS compromis pour lui transmettre de l’information. Dans le cas présent, en essayant de retrouver l’IP de l’URL “_akpmnc.exemple.com_”, par le biais du protocole DNS, le serveur DNS “exemple.com” sera interrogé à propos de la machine “_akpmnc_”. Même si cette machine n’existe pas, si un adversaire malveillant contrôle le serveur DNS responsable de la zone “_exemple.com_”, il sera capable de récupérer la chaine “_akpmnc_”, et donc de lire de l’information extraite de la machine victime.

[L'exfiltration DNS](https://blogs.akamai.com/2017/09/introduction-to-dns-data-exfiltration.html) a l'avantage d’utiliser un protocole [très rarement filtré et surveillé](http://www.caida.org/~nevil/Bojan_Zdrnja_CompSci780_Project.pdf).

### 2) Exfiltration
Avant toute chose, le cache DNS est nettoyé avec la commande “_ipconfig /flushdns_”:
![picture](/img/DarkHydrus/ZA.PNG){:class="img-responsive"}

La commande powershell est exécutée de manière transparente pour l’utilisateur de la machine infectée:
![picture](/img/DarkHydrus/ZB.PNG){:class="img-responsive"}

Le malware utilise le binaire légitime “_nslookup.exe_” pour pratiquer l’exfiltration DNS. La commande [nslookup](https://en.wikipedia.org/wiki/Nslookup) est initialisée en fonction du mode de requête DNS souhaité, du timeout, et du domaine d’exfiltration:
![picture](/img/DarkHydrus/ZC.PNG){:class="img-responsive"}

Les types de requêtes DNS disponibles sont les suivantes:
![picture](/img/DarkHydrus/ZD.PNG){:class="img-responsive"}

Et la liste des domaines à contacter sont les suivants:
![picture](/img/DarkHydrus/ZE.PNG){:class="img-responsive"}

Ainsi la première commande effectuée par le malware est la suivante:
![picture](/img/DarkHydrus/ZF.PNG){:class="img-responsive"}

A noter qu’une nouvelle technique anti-debug est utilisée avant d’effectuer les commandes d’exfiltration DNS (bien que très sommaire). Si un débugger est détecté par le malware, alors aucun domaine d’exfiltration n’est contacté, et des informations inutiles sont transférées à un domaine légitime de google:
![picture](/img/DarkHydrus/ZG.PNG){:class="img-responsive"}

La chaine “_676f6f646c75636b_” est en fait un message de la part de l'auteur du malware, qui nous est directement destiné. Celui-ci correspond à la chaine hexadécimale “_goodluck_”:
![picture](/img/DarkHydrus/ZH.PNG){:class="img-responsive"}

Si tout se passe bien, la commande d’exfiltration générée plus tôt est enfin exécutée:
![picture](/img/DarkHydrus/ZI.PNG){:class="img-responsive"}
![picture](/img/DarkHydrus/ZJ.PNG){:class="img-responsive"}

Afin de vérifier si la requête a été correctement transmise, le malware analyse le retour de la commande nslookup:
![picture](/img/DarkHydrus/ZK.PNG){:class="img-responsive"}

Le malware va continuer de sélectionner un type de message DNS aléatoire associé à l’entièreté de la liste de domaine à contacter, jusqu'à tomber sur un serveur en ligne.

Puisque la liste des serveurs de contrôle est trop vieille à l’heure de mon analyse, j’utilise ici l’outil ApateDNS pour retourner une réponse positive à toutes les requêtes effectuées par le malware:
![picture](/img/DarkHydrus/ZL.PNG){:class="img-responsive"}

De ce fait, le malware considère les serveurs de contrôle comme en ligne, en passant la variable “_flag_” à la valeur “_true_”:
![picture](/img/DarkHydrus/ZM.PNG){:class="img-responsive"}

Le résultat de la réponse DNS de la part du serveur de contrôle est ensuite stockée, de façon à transmettre des ordres au malware.

### D) Récolte d’informations systèmes
Le malware récupère quelques informations sur la machine victime avant de les envoyer au serveur de contrôle.
Ces informations concernent l’adresse IP de la machine, le nom de la machine, le domaine et le nom d’utilisateur de la session:
![picture](/img/DarkHydrus/ZN.PNG){:class="img-responsive"}

La prochaine information récoltée concerne les privilèges utilisateurs avec lesquels le malware a été lancé. A noter qu’une erreur de conception rend cette fonction du programme uniquement opérationnel sur une machine dont le langage est réglé en anglais. La fonction est la suivante:
![picture](/img/DarkHydrus/ZP.PNG){:class="img-responsive"}

La fonction retourne donc un des trois cas suivants:
![picture](/img/DarkHydrus/tab1.PNG){:class="img-responsive"}

L’erreur de conception de la fonction réside dans le fait que le groupe administrateur d’une machine Windows possède une syntaxe dépendant de la langue d’utilisation, alors que dans le cas présent, le nom du groupe est hardcodé:
![picture](/img/DarkHydrus/ZO.PNG){:class="img-responsive"}

Le malware n’est donc pas capable de déterminer les privilèges utilisateurs sur une machine non anglaise.

Ces informations sont concaténées ensemble, en plus de quelques informations supplémentaires, tel que le temps de pause que le malware va utiliser par défaut ou la présence de la méthode de persistance:
![picture](/img/DarkHydrus/ZQ.PNG){:class="img-responsive"}

La chaine finale contenant les informations à exfiltrer est ensuite convertie en hexadécimale:
![picture](/img/DarkHydrus/ZR.PNG){:class="img-responsive"}

Si le malware a été compilé avec le flag “_x_mode_” à la valeur _true_, alors RogueRobin va initialiser l’exfiltration au travers d’un document partagé Google Docs, de façon à masquer le flux sortant en le faisant passer pour légitime:
![picture](/img/DarkHydrus/ZS.PNG){:class="img-responsive"}

Si le flag “_x_mode_” n’est pas activé, les informations sont infiltrées via la technique reposant sur le protocole DNS.

### E) C2 Instruction handler
A partir du moment où les informations permettant d’identifier une machine cliente sont transmises au serveur de contrôle, le malware reste en hibernation, et attente d’ordre. Lorsqu’une information est reçue par le malware, celle-ci peut provenir d’une page Google Docs (la même qui sert pour l’exfiltration de données), ou toujours via des réponses à des requêtes DNS.

A l’arrivée d’une commande provenant du serveur de contrôle, les données sont parsés puis converties de l'hexadécimal à l’ASCII. Celles-ci sont ensuite envoyées à la fonction “_taskHandler_”, qui exécutera l’instruction dans un nouveau thread:
![picture](/img/DarkHydrus/ZT.PNG){:class="img-responsive"}

Les instructions proposées sont les suivantes:
* _^kill_
Un processus en cours est terminé, en fonction de son PID:
![picture](/img/DarkHydrus/ZU.PNG){:class="img-responsive"}

* _^\\$fileDownload_
Un fichier local de la machine infectée est envoyé au serveur de contrôle:
![picture](/img/DarkHydrus/ZV.PNG){:class="img-responsive"}

* _^\\$importModule_
Exécute une commande ou un script powershell. Cette commande est désormais présente au sein d’une liste de modules, accessibles par la suite:
![picture](/img/DarkHydrus/ZW.PNG){:class="img-responsive"}

* _^\\$ClearModules_
La liste des précédentes commandes powershell (modules) est effacée:
![picture](/img/DarkHydrus/ZX.PNG){:class="img-responsive"}

* _^\\$file_Upload_
Une ressource provenant du serveur de contrôle est téléchargée dans un répertoire précisé par l’opérateur du malware:
![picture](/img/DarkHydrus/ZY.PNG){:class="img-responsive"}

* _^testmode_
La communication entre le serveur de contrôle et le sample est testée, via une requête DNS dont le contenu correspond à la chaine “testmode”:
![picture](/img/DarkHydrus/ZZ.PNG){:class="img-responsive"}

* _^exit_
Le processus parent du malware est terminé:
![picture](/img/DarkHydrus/ZZA.PNG){:class="img-responsive"}

* _^slp_
Une nouvelle valeur est attribuée au temps de pause utilisé par le malware entre certaines actions (entre l’envoi de plusieurs requêtes par exemple):
![picture](/img/DarkHydrus/ZZB.PNG){:class="img-responsive"}

* _^changeConfig_
Mets à jour certaines informations du malware, notamment la liste des domaines malicieux à contacter:
![picture](/img/DarkHydrus/ZZC.PNG){:class="img-responsive"}

Mais c’est aussi la taille maximale et minimum des requêtes qui peut être modifiée, tout comme la durée d’attente entre l’envoi de deux messages, la présence ou non de données additionnelles dans les requêtes (attribut ‘_hasGarbage_’), le type de requête DNS à utiliser pour l’exfiltration de données ou pour contacter le serveur et le nombre de requêtes maximum avant de considérer un domaine ne répondant pas comme étant down.

* _^showConfig_
Retourne la configuration actuelle du malware, à savoir les valeurs précédemment énumérées :
![picture](/img/DarkHydrus/ZZD.PNG){:class="img-responsive"}

* _^\\$x_mode_
Active (ou désactive) les capacités de communication au travers d’un fichier GoogleDocs:
![picture](/img/DarkHydrus/ZZE.PNG){:class="img-responsive"}

### Indicateurs d’infection
hash du binaire : _2f22d521a1945d02380057a636e1032b_

domaines contactés: _0ffice365.agency_, _0nedrive.agency_, _corewindows.agency_, _microsoftonline.agency_, _onedrive.agency_, _sharepoint.agency_, _skydrive.agency_, _0ffice365.life_, _0ffice365.services_, _skydrive.services_

Fichier système : _%APPDATA%\OneDrive.exe_

Fichier système: _C:\Users\<user name>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\OneDrive.lnk_

![picture](/img/DarkHydrus/yara.PNG){:class="img-responsive"}
